Cov_diag_full <- R_S_mat * (1-R_S_mat)
# tR_S_mat_inv <- t(R_S_mat_inv)
tR_S_mat <- t(R_S_mat)
# res_mat <- apply(Cov_diag_full, 1, function(cov_row) {
#   tR_S_mat_inv %*% diag(cov_row) %*% R_S_mat_inv
# })
res_mat <- apply(Cov_diag_full, 1, function(cov_row) {
R_S_mat %*% diag(1/cov_row) %*% tR_S_mat
})
Sigma_inv <- array(res_mat, dim = c(K, K, K))
.proj.sdp <- function(X,eps=1e-7) {
X <- as.matrix(X)
X <- (X + t(X)) / 2
evd_X <- eigen(X, symmetric = TRUE)
d <- evd_X$values
d <- pmax(d, eps)
X <- evd_X$vectors %*% diag(d) %*% t(evd_X$vectors)
(X + t(X)) / 2
}
Sigma_inv <- (apply(Sigma_inv, 1, .proj.sdp))
Sigma_inv <- array(as.vector(Sigma_inv), dim = c(K, K, K))
Sigma_inv
}
Cov_S_inv <- .var_A(U, Sigma, V, S_f)
Cov_S_k_inv <- as.matrix(Cov_S_inv[k,,])
eigen(Cov_S_k_inv)
## This return K covariance matrices
.var_A <- function(U_est, Sigma, V_est, S){
K <- ncol(U_est)
N <- nrow(U_est)
J <- nrow(V_est)
R_est <- U_est %*% diag(Sigma) %*% t(V_est)
R_S_mat <- R_est[S,]
# R_S_mat_inv <- MASS::ginv(R_S_mat)
Cov_diag_full <- R_S_mat * (1-R_S_mat)
# tR_S_mat_inv <- t(R_S_mat_inv)
tR_S_mat <- t(R_S_mat)
# res_mat <- apply(Cov_diag_full, 1, function(cov_row) {
#   tR_S_mat_inv %*% diag(cov_row) %*% R_S_mat_inv
# })
res_mat <- apply(Cov_diag_full, 1, function(cov_row) {
R_S_mat %*% diag(1/cov_row) %*% tR_S_mat
})
Sigma_inv <- array(res_mat, dim = c(K, K, K))
.proj.sdp <- function(X,eps=1e-3) {
X <- as.matrix(X)
X <- (X + t(X)) / 2
evd_X <- eigen(X, symmetric = TRUE)
d <- evd_X$values
d <- pmax(d, eps)
X <- evd_X$vectors %*% diag(d) %*% t(evd_X$vectors)
(X + t(X)) / 2
}
Sigma_inv <- (apply(Sigma_inv, 1, .proj.sdp))
Sigma_inv <- array(as.vector(Sigma_inv), dim = c(K, K, K))
Sigma_inv
}
Cov_S_inv <- .var_A(U, Sigma, V, S_f)
Cov_S_k_inv <- as.matrix(Cov_S_inv[k,,])
eigen(Cov_S_k_inv)
.proj.sdp <- function(X,eps=1e-3) {
X <- as.matrix(X)
X <- (X + t(X)) / 2
evd_X <- eigen(X, symmetric = TRUE)
d <- evd_X$values
d <- pmax(d, eps)
X <- evd_X$vectors %*% diag(d) %*% t(evd_X$vectors)
(X + t(X)) / 2
}
Cov_S_k_inv <- as.matrix(Cov_S_inv[k,,])
Cov_S_k_inv <- .proj.sdp(Cov_S_k_inv)
diff_mat <- Us - Us[S[k],]
dist_m <- diag(diff_mat %*% Cov_S_k_inv %*% t(diff_mat))
dist_m
plot(dist_m)
# dist_m <- mahalanobis(Us, Us[S[k],], Cov_S_k_inv, inverted = T)
idx_k <- (abs(dist_m) <= 2*sqrt(log(max(N,J))))
plot(U_norm[,2],U_norm[,3])
points(U_norm[idx_k,2],U_norm[idx_k,3],col="red")
plot(dist_m)
abline(h=2*sqrt(log(max(N,J))),col="red")
dist_m <- mahalanobis(Us, Us[S[k],], Cov_S_k_inv, inverted = T)
plot(dist_m)
abline(h=2,col="red")
abline(h=1,col="red")
# idx_k <- (abs(dist_m) <= 2*sqrt(log(max(N,J))))
idx_k <- dist_m <= 1
colMeans(Us[idx_k,])
plot(U_norm[,2],U_norm[,3])
points(U_norm[idx_k,2],U_norm[idx_k,3],col="red")
k <- 2
Cov_S_k_inv <- as.matrix(Cov_S_inv[k,,])
Cov_S_k_inv <- .proj.sdp(Cov_S_k_inv)
diff_mat <- Us - Us[S[k],]
dist_m <- diag(diff_mat %*% Cov_S_k_inv %*% t(diff_mat))
dist_m <- mahalanobis(Us, Us[S[k],], Cov_S_k_inv, inverted = T)
# idx_k <- (abs(dist_m) <= 2*sqrt(log(max(N,J))))
idx_k <- dist_m <= 1
plot(U_norm[,2],U_norm[,3])
points(U_norm[idx_k,2],U_norm[idx_k,3],col="red")
plot(dist_m)
k <- 3
Cov_S_k_inv <- as.matrix(Cov_S_inv[k,,])
Cov_S_k_inv <- .proj.sdp(Cov_S_k_inv)
diff_mat <- Us - Us[S[k],]
dist_m <- diag(diff_mat %*% Cov_S_k_inv %*% t(diff_mat))
dist_m <- mahalanobis(Us, Us[S[k],], Cov_S_k_inv, inverted = T)
# idx_k <- (abs(dist_m) <= 2*sqrt(log(max(N,J))))
idx_k <- dist_m <= 1
plot(U_norm[,2],U_norm[,3])
points(U_norm[idx_k,2],U_norm[idx_k,3],col="red")
plot(dist_m)
diff_mat <- t(t(Us) - Us[S[k],])
dist_m <- diag(diff_mat %*% Cov_S_k_inv %*% t(diff_mat))
dist_m
source("~/Programmes/CRYSTAL/CRYSTAL.R", echo=TRUE)
A_gen <- function(N, K){
A_zeros <- matrix(0, nrow = ceiling(N/(2*(K+1))), ncol = K)
A_identity <- diag(1, K)
A_identity <- matrix(rep(A_identity, ceiling(N/5/K)), ncol = K, byrow = T)
A_res <- matrix(rbinom((N-ceiling(N/5/K)*K-ceiling(N/(2*(K+1))))*K, 1, 0.5), ncol = K)
A <- rbind(A_zeros, A_identity, A_res)
return(A[1:N,])
}
Q_gen_sparse <- function(J,K){
I1 <- diag(1,K,K)
I2 <- I1
I2[row(I2)-col(I2) == -1] <- 1
I2[K,1] <- 1
I3 <- I2
I3[row(I3)-col(I3) == 1] <- 1
I3[1,K] <- 1
Q1 <- do.call(rbind, replicate(ceiling(J/K/2), I1, simplify = F))
Q2 <- do.call(rbind, replicate(ceiling(J/K/4), I2, simplify = F))
Q3 <- do.call(rbind, replicate(ceiling(J/K/4), I3, simplify = F))
Q <- rbind(Q1,Q2,Q3)
idx <- sample(1:nrow(Q), J)
Q <- Q[idx,]
return(Q)
}
Theta_gen <- function(J,K,Q,nm=0.8){
Theta = matrix(runif(J*K),nrow=J)
q_sum <- rowSums(Q)
assign_theta <- function(j){
(rexp(K) + 1.5) * Q[j,]
}
Theta <- t(sapply(1:J, assign_theta))
Theta
}
gen_data_int_sp <- function(N,J,K){
# d = runif(J,0,0.2)
d <- rep(0.1,J)
A = A_gen(N,K)
Q = Q_gen_sparse(J,K)
Theta = Theta_gen(J,K,Q,nm=0.9)
R_r = A%*%t(Theta)+matrix(rep(d, N), nrow = N, byrow = T)
# R = matrix(rbinom(N*J,1,R_r),nrow = N)
R <- matrix(rpois(N*J, R_r), nrow = N)
R[is.na(R)] = 1
return(list(d=d,R=R,Q=Q,Theta=Theta,A=A))
}
find_best_idx <- function(EX,X){
loss.mad <- t(apply(X, 2, function(x) colMeans(abs(x - EX))))
od = clue::solve_LSAP(loss.mad)
return(od)
}
single_loop_int_sp <- function(i,N,J,K){
set.seed(i)
gen.dat = gen_data_int_sp(N,J,K)
d = gen.dat$d
R = gen.dat$R
Q = gen.dat$Q
A = gen.dat$A
Theta = gen.dat$Theta
est_SCORE = CRYSTAL_int_sp(R,K)
A.od = find_best_idx(est_SCORE$A,A)
Q_err = sum(est_SCORE$Q[,A.od]!=Q)/length(Q)
A_err = sum(est_SCORE$A[,A.od]!=A)/length(A)
# zero_one = sum(Q==0 & est_SCORE$Q[,A.od]!=0)/length(Q)
Theta_err <- mean(abs(est_SCORE$Theta[,A.od]-Theta))
d_err <- mean(abs(est_SCORE$d-d))
est_SCORE0 <- CRYSTAL_int_sp0(R,K)
A.od0 = find_best_idx(est_SCORE0$A,A)
Q_err0 = sum(est_SCORE0$Q[,A.od0]!=Q)/length(Q)
A_err0 = sum(est_SCORE0$A[,A.od0]!=A)/length(A)
# zero_one0 = sum(Q==0 & est_SCORE0$Q[,A.od0]!=0)/length(Q)
Theta_err0 <- mean(abs(est_SCORE0$Theta[,A.od0]-Theta))
d_err0 <- mean(abs(est_SCORE0$d-d))
return(list(Q_err=Q_err,A_err=A_err,Theta_err=Theta_err,d_err=d_err,
Q_err0=Q_err0,A_err0=A_err0,Theta_err0=Theta_err0,d_err0=d_err0))
}
i <- 1
N <- 500
J <- 500
K <- 3
gen.dat = gen_data_int_sp(N,J,K)
d = gen.dat$d
R = gen.dat$R
Q = gen.dat$Q
A = gen.dat$A
Theta = gen.dat$Theta
est_SCORE0 <- CRYSTAL_int_sp0(R,K)
CRYSTAL_int_sp0 <- function(R,K,thres=.5){
# R is the response matrix
# thres is the threshold to 1 for any larger value
# L2=T indicates L2 normalization
# L2=F indicates SCORE normalization
N = nrow(R)
J = ncol(R)
# svd1.R = svd(R,nu=K+1,nv=K+1)
svd1.R <- RSpectra::svds(R, K+1)
if (all(svd1.R$u[,1]<=1e-14)){
svd1.R$u = -svd1.R$u
svd1.R$v = -svd1.R$v
}
# Thresholding to 0
R_est <- svd1.R$u %*% diag(svd1.R$d) %*% t(svd1.R$v)
idx_min <- which.min(svd1.R$u[,1])
var_est <- .var_U1(R_est, svd1.R$v, svd1.R$d, idx_min)
idx_zero <- svd1.R$u[,1] <= (svd1.R$u[idx_min,1] +
2*sqrt(var_est)*log(max(N,J)))
# D = svd1.R$u[km_u1$cluster==smallest_clust,]%*%(svd1.R$d[1:(K+1)]*t(svd1.R$v))
# D <- svd1.R$u[idx_zero,]%*%(svd1.R$d*t(svd1.R$v))
d <-  colMeans(R_est[idx_zero,])
# D <- matrix(rep(d,nrow(R)),nrow=N,byrow = T)
# Rs <- svd1.R$u%*%(svd1.R$d*t(svd1.R$v)) - D
# Rs[Rs < 0] <- 0
U_new <- svd1.R$u - colMeans(svd1.R$u[idx_zero,])
# svd2.R = svd(Rs,nu=K,nv=K)
# svd2.R = RSpectra::svds(Rs,K)
# idx_zero <- km_u1$cluster == smallest_clust
idx_zero <- clust_all0
# find the set of 1 to K
# res_A = .A.est0(svd2.R$u,idx_zero,thres)
res_A <- .A.est0(U_new,idx_zero,thres,K)
A <- res_A$A
S <- res_A$S
## Estimate Q matrix
# Theta <- .Theta.sp.est(svd1.R$u,svd1.R$d,svd1.R$v,A)
# Theta <- .Theta.sp.est(svd1.R$u,svd1.R$d,svd1.R$v,A,S)
Theta <- .Theta.sp.est(U_new,svd1.R$d,svd1.R$v,A,S)
Q <- matrix(as.numeric(Theta > 0), ncol=K)
return(list(d = d ,A = A, Q = Q, Theta = Theta))
}
est_SCORE0 <- CRYSTAL_int_sp0(R,K)
CRYSTAL_int_sp0 <- function(R,K,thres=.5){
# R is the response matrix
# thres is the threshold to 1 for any larger value
# L2=T indicates L2 normalization
# L2=F indicates SCORE normalization
N = nrow(R)
J = ncol(R)
# svd1.R = svd(R,nu=K+1,nv=K+1)
svd1.R <- RSpectra::svds(R, K+1)
if (all(svd1.R$u[,1]<=1e-14)){
svd1.R$u = -svd1.R$u
svd1.R$v = -svd1.R$v
}
# Thresholding to 0
R_est <- svd1.R$u %*% diag(svd1.R$d) %*% t(svd1.R$v)
idx_min <- which.min(svd1.R$u[,1])
var_est <- .var_U1(R_est, svd1.R$v, svd1.R$d, idx_min)
idx_zero <- svd1.R$u[,1] <= (svd1.R$u[idx_min,1] +
2*sqrt(var_est)*log(max(N,J)))
# D = svd1.R$u[km_u1$cluster==smallest_clust,]%*%(svd1.R$d[1:(K+1)]*t(svd1.R$v))
# D <- svd1.R$u[idx_zero,]%*%(svd1.R$d*t(svd1.R$v))
d <-  colMeans(R_est[idx_zero,])
# D <- matrix(rep(d,nrow(R)),nrow=N,byrow = T)
# Rs <- svd1.R$u%*%(svd1.R$d*t(svd1.R$v)) - D
# Rs[Rs < 0] <- 0
U_new <- svd1.R$u - colMeans(svd1.R$u[idx_zero,])
# svd2.R = svd(Rs,nu=K,nv=K)
# svd2.R = RSpectra::svds(Rs,K)
# idx_zero <- km_u1$cluster == smallest_clust
# idx_zero <- clust_all0
# find the set of 1 to K
# res_A = .A.est0(svd2.R$u,idx_zero,thres)
res_A <- .A.est0(U_new,idx_zero,thres,K)
A <- res_A$A
S <- res_A$S
## Estimate Q matrix
# Theta <- .Theta.sp.est(svd1.R$u,svd1.R$d,svd1.R$v,A)
# Theta <- .Theta.sp.est(svd1.R$u,svd1.R$d,svd1.R$v,A,S)
Theta <- .Theta.sp.est(U_new,svd1.R$d,svd1.R$v,A,S)
Q <- matrix(as.numeric(Theta > 0), ncol=K)
return(list(d = d ,A = A, Q = Q, Theta = Theta))
}
est_SCORE0 <- CRYSTAL_int_sp0(R,K)
SCORE <- function(U, K=NULL){
if (is.null(K)){
K = ncol(U)
}
P = NA
## pseudo-pruning
if (any(U[,1]<=1e-7)){
P = which(U[,1]<=1e-7)
U0 = U[-P,]
Us = U0/U0[,1]
} else {
Us = U/U[,1]
}
if (!any(is.na(P))){
idx_new <- (1:nrow(U))[-P]
}
IK = diag(rep(1,ncol(U)))
S = c()
Y0 = Us
Y = Y0
for (k in 1:K) {
l = apply(Y,1,norm,"2")
S = c(S,which.max(l))
u = Y[S[k],]/norm(Y[S[k],],"2")
u = data.matrix(u)
Y = Y%*%(IK-u%*%t(u))
}
if (!any(is.na(P))){
S <- idx_new[S]
}
return(S)
}
est_SCORE0 <- CRYSTAL_int_sp0(R,K)
.A.est0 <- function(U, idx_zero, thres = .5, K = NULL){
N = nrow(U)
if (is.null(K)){
K = ncol(U)
}
Us = U[!idx_zero,]
idx_new <- (1:N)[!idx_zero]
S = SCORE(Us, K)
S <- sort(S)
A = matrix(rep(0,N*K),nrow=N)
# A_mixed = Us%*%solve(Us[S,])
A_mixed <- Us%*%MASS::ginv(Us[S,])
A[!idx_zero,] = as.numeric(A_mixed>=thres)
# A[!idx_zero,] = as.numeric(A_mixed)
S <- idx_new[S]
list(A=A,S=S)
}
est_SCORE0 <- CRYSTAL_int_sp0(R,K)
A.od0 = find_best_idx(est_SCORE0$A,A)
A_err0 = sum(est_SCORE0$A[,A.od0]!=A)/length(A)
A_err0
# svd1.R = svd(R,nu=K+1,nv=K+1)
svd1.R <- RSpectra::svds(R, K+1)
if (all(svd1.R$u[,1]<=1e-14)){
svd1.R$u = -svd1.R$u
svd1.R$v = -svd1.R$v
}
# Thresholding to 0
R_est <- svd1.R$u %*% diag(svd1.R$d) %*% t(svd1.R$v)
idx_min <- which.min(svd1.R$u[,1])
var_est <- .var_U1(R_est, svd1.R$v, svd1.R$d, idx_min)
idx_zero <- svd1.R$u[,1] <= (svd1.R$u[idx_min,1] +
2*sqrt(var_est)*log(max(N,J)))
plot(svd1.R$u[,1])
abline(h=svd1.R$u[idx_min,1] +
2*sqrt(var_est)*log(max(N,J)))
# D = svd1.R$u[km_u1$cluster==smallest_clust,]%*%(svd1.R$d[1:(K+1)]*t(svd1.R$v))
# D <- svd1.R$u[idx_zero,]%*%(svd1.R$d*t(svd1.R$v))
d <-  colMeans(R_est[idx_zero,])
# D <- matrix(rep(d,nrow(R)),nrow=N,byrow = T)
# Rs <- svd1.R$u%*%(svd1.R$d*t(svd1.R$v)) - D
# Rs[Rs < 0] <- 0
U_new <- svd1.R$u - colMeans(svd1.R$u[idx_zero,])
library(plotly)
plot_ly(x=U_new[,1],y=U_new[,2],z=U_new[,3])
str(U_new)
View(U_new)
U_norm <- U_new[!idx_zero,] / U_new[!idx_zero,1]
plot(U_norm[,2],U_norm[,3])
plot_ly(U_norm[,2], U_norm[,3], U_norm[,4])
plot_ly(x=U_norm[,2], y=U_norm[,3], z=U_norm[,4])
source("~/Programmes/CRYSTAL/CRYSTAL.R", echo=TRUE)
est_SCORE0 <- CRYSTAL_int_sp0(R,K)
A.od0 = find_best_idx(est_SCORE0$A,A)
A_err0 = sum(est_SCORE0$A[,A.od0]!=A)/length(A)
A_err0
# zero_one0 = sum(Q==0 & est_SCORE0$Q[,A.od0]!=0)/length(Q)
Theta_err0 <- mean(abs(est_SCORE0$Theta[,A.od0]-Theta))
Theta_err0
d_err0 <- mean(abs(est_SCORE0$d-d))
d_err0
d_err0 <- mean(abs(est_SCORE0$d-d))
d_err0
est_SCORE$d
A.od0(est_SCORE0$A,gen.dat$A)
A.od0 <- find_best_idx(est_SCORE0$A,gen.dat$A)
A_err <- sum(est_SCORE$A[,A.od]!=gen.dat$A)/length(A)
A_err <- sum(est_SCORE0$A[,A.od]!=gen.dat$A)/length(A)
A_err <- sum(est_SCORE0$A[,A.od0]!=gen.dat$A)/length(A)
A_err
d_err0 <- mean(abs(est_SCORE0$d-gen.dat$d))
d_err0
N <- 2000
J <- 2000
K <- 3
gen.dat = gen_data_int_sp(N,J,K)
d = gen.dat$d
R = gen.dat$R
Q = gen.dat$Q
A = gen.dat$A
Theta = gen.dat$Theta
# svd1.R = svd(R,nu=K+1,nv=K+1)
svd1.R <- RSpectra::svds(R, K+1)
if (all(svd1.R$u[,1]<=1e-14)){
svd1.R$u = -svd1.R$u
svd1.R$v = -svd1.R$v
}
# Thresholding to 0
R_est <- svd1.R$u %*% diag(svd1.R$d) %*% t(svd1.R$v)
idx_min <- which.min(svd1.R$u[,1])
var_est <- .var_U1(R_est, svd1.R$v, svd1.R$d, idx_min)
idx_zero <- svd1.R$u[,1] <= (svd1.R$u[idx_min,1] +
2*sqrt(var_est)*log(max(N,J)))
plot(svd1.R$u[,1])
abline(h=svd1.R$u[idx_min,1] +
2*sqrt(var_est)*log(max(N,J)))
abline(h=svd1.R$u[idx_min,1] +
2*sqrt(var_est)*log(max(N,J)),col="red")
sum(svd1.R$u[,1]<=svd1.R$u[idx_min,1] +
+            2*sqrt(var_est)*log(max(N,J)))
sum(svd1.R$u[,1]<=0.01)
svd1.R$d
K <- 10
gen.dat = gen_data_int_sp(N,J,K)
N <- 5000
J <- 5000
gen.dat = gen_data_int_sp(N,J,K)
d = gen.dat$d
R = gen.dat$R
Q = gen.dat$Q
A = gen.dat$A
Theta = gen.dat$Theta
svds(R,K+1)$d
RSpectra::svds(R,K+1)$d
path <- getwd()
setwd("~/Programmes/CCAGLM")
path <- getwd()
path_pisa <- file.path(path, "PISA", "2018")
pisa2018 <- readPISA(
path = path_pisa,
countries = c("TAP"),
verbose = TRUE
)
library(EdSurvey)
pisa2018 <- readPISA(
path = path_pisa,
countries = c("TAP"),
verbose = TRUE
)
View(pisa2018)
pisa_tap <- EdSurvey::getData(pisa2018, varnames = "survey")
EdSurvey::getData(pisa2018, varnames = "student")
pisa2018
pisa_tap <- EdSurvey::getData(pisa2018, varnames = "math")
varnames <- c("math", "read", "scie", "glcm", "rcli", "rcun",
"rcer", "rtsn", "rtml")
pisa_tap <- EdSurvey::getData(pisa2018, varnames = "math")
pisa_tap <- EdSurvey::getData(pisa2018, varnames = varnames)
showCodebook(pisa2018)
all_var_names <- showCodebook(pisa2018)
View(all_var_names)
A_gen <- function(N,K,p=NULL){
I1 <- diag(1,K,K)
I2 <- matrix(rep(I1, 5), ncol = K, byrow = T)
# I3 <- matrix(rep(0, 5*K), ncol = K)
A_res <- matrix(rbinom((N-nrow(I2))*K, 1, 0.5), ncol = K)
A <- rbind(I2, A_res)
all_zeros <- which(apply(A, 1, function(x) all(x == 0)))
if (length(all_zeros) > 0) {
A[all_zeros, ] <- t(rmultinom(length(all_zeros), 1, rep(1/K, K)))
}
A
}
N <- 500
J <- 500
K <- 2
A <- A_gen(N, K)
A_gen <- function(N, K){
A_zeros <- matrix(0, nrow = ceiling(N/(2*(K+1))), ncol = K)
A_identity <- diag(1, K)
A_identity <- matrix(rep(A_identity, ceiling(N/3/K)), ncol = K, byrow = T)
A_res <- matrix(rbinom((N-ceiling(N/5/K)*K-ceiling(N/(2*(K+1))))*K, 1, 0.5), ncol = K)
A <- rbind(A_zeros, A_identity, A_res)
return(A[1:N,])
}
N <- 1000
J <- 1000
K <- 2
A <- A_gen(N, K)
d <- rep(0.5, J)
Theta <- matrix(rnorm(J * K), nrow = J, ncol = K)
R <- rep(1, N) %*% t(d) + A %*% t(Theta)
idx_01 <- apply(A, 1, function(x) all(x == c(0,1)))
set.seed(1234)
N <- 1000
J <- 1000
K <- 2
A <- A_gen(N, K)
d <- rep(0.5, J)
Theta <- matrix(rnorm(J * K), nrow = J, ncol = K)
R <- rep(1, N) %*% t(d) + A %*% t(Theta)
idx_01 <- apply(A, 1, function(x) all(x == c(0,1)))
idx_10 <- apply(A, 1, function(x) all(x == c(1,0)))
idx_11 <- apply(A, 1, function(x) all(x == c(1,1)))
idx_00 <- apply(A, 1, function(x) all(x == c(0,0)))
A_2 <- A
A_2[idx_01, ] <- c(0,0)
A_2[idx_10, ] <- c(1,1)
A_2[idx_11, ] <- c(0,1)
A_2[idx_00, ] <- c(1,0)
d_2 <- colMeans(R[idx_01, ])
